# Cursor IDE Agent Rules

Guidelines for Cursor AI to work effectively in parallel with Claude Code and Cline on the Radium project.

## Project Context

**Radium**: A comprehensive multi-agent orchestration platform built with Rust (backend) and modern web technologies (frontend).

### Key Components

- **Core**: gRPC server with workflow engine, agent orchestration, and storage
- **Models**: AI model abstractions and provider implementations (OpenAI, Gemini)
- **Apps**: CLI, TUI, and Desktop (Tauri) interfaces
- **Orchestrator**: Agent lifecycle management, execution queue, plugin system

## Collaboration Model

Multiple agents work in parallel on this project:
- **Claude Code**: Primary implementation agent
- **Cline**: Testing, documentation, refactoring
- **Cursor**: Interactive development, quick fixes, code analysis

All agents follow the guidelines in `roadmap/CLAUDE_RULES.md` and update `roadmap/PROGRESS.md` consistently.

## Before Starting Any Work

1. **Check Status**: Read `roadmap/PROGRESS.md` to see what's in progress
2. **Check Rules**: Review `roadmap/CLAUDE_RULES.md` for shared standards
3. **Update Progress**: Mark your task as "In Progress - Cursor" before starting
4. **Plan Commits**: Decide how to break work into atomic, mergeable commits

## Recommended Focus Areas

Cursor is well-suited for:

- **Interactive Debugging**: Using Cursor's debug capabilities to trace issues
- **Rapid Iteration**: Quick edits with immediate feedback
- **Code Analysis**: Understanding existing code patterns and structure
- **IDE-Integrated Testing**: Running tests from Cursor interface
- **Quick Fixes**: Small improvements, warnings cleanup, formatting
- **Code Navigation**: Jump to definitions, find references

## Development Workflow

### Typical Session

1. Open relevant files for your task
2. Use Cursor's code intelligence for navigation
3. Make focused changes with clear commit boundaries
4. Run tests/linting from integrated terminal
5. Commit with proper message format
6. Update progress tracking

### Command Reference

```bash
# Build
cargo build --all

# Run specific project
cargo run --bin radium-core
cargo run --bin radium-cli
cargo run --bin radium-tui

# Test
cargo test --all
cargo test --all -- --nocapture  # With output

# Format and lint
cargo fmt --all
cargo clippy --all

# Desktop app
cd apps/desktop
bun install
bun run dev
bun run build
```

## Code Standards

### Rust Code

- No unsafe code (workspace forbids it)
- Follow Clippy lints (whitelisted exceptions in Cargo.toml)
- Use async/await with Tokio
- Error handling with thiserror
- Thread-safe with Arc/Mutex where needed
- Meaningful variable names, brief comments on complex logic

### TypeScript/JavaScript

- Follow project linting rules
- Use proper error handling
- Async patterns consistent with project
- Type safety where applicable

### Comments

- Avoid obvious comments (`// set x to 5`)
- Explain WHY, not WHAT
- Document non-intuitive algorithms
- Include references for complex logic

## Testing Expectations

### When to Write Tests

- All new public functions
- Bug fixes (write test that reproduces bug first)
- Complex logic requiring validation
- Integration points between modules

### Test Location

```
Module: core/src/module.rs
Tests: core/src/module.rs (unit tests)
       core/tests/integration_test.rs (integration)
```

### Test Pattern

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_description_of_behavior() {
        // Setup
        let input = setup_fixture();

        // Execute
        let result = function_under_test(input);

        // Assert
        assert_eq!(result, expected_value);
    }
}
```

## Git Workflow

### Commit Message Format

```
<type>(<scope>): <subject> [<issue>]

<body>

<footer>
```

**Types**: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`

**Example**:
```
feat(orchestrator): implement priority queue for task execution [RAD-049]

- Add priority field to Task model
- Implement priority-based sorting in ExecutionQueue
- Add comprehensive tests for priority ordering

ðŸ¤– Cursor
Co-Authored-By: Cursor <noreply@anthropic.com>
```

### Commit Size

- Small, focused commits (~50-200 lines per commit)
- One logical change per commit
- Make it easy to review and revert if needed

## Quality Checklist

Before pushing any changes:

```
â–¡ Code compiles: cargo build --all
â–¡ Tests pass: cargo test --all
â–¡ No clippy warnings: cargo clippy --all
â–¡ Formatted correctly: cargo fmt --all
â–¡ Progress file updated with completion
â–¡ Commit message follows format
â–¡ No unsafe code introduced
â–¡ Tests cover the changes
```

## Conflict Resolution

### If Another Agent is Working on Same Area

1. Check `roadmap/PROGRESS.md` for "In Progress" status
2. If conflict found:
   - Pick a different task from the roadmap
   - Or coordinate with the other agent
3. Update progress immediately

### If Work Doesn't Apply Cleanly

- Don't force merges
- Document the blocker in `PROGRESS.md`
- Pick another task
- Mark as "Blocked" with explanation

## Using Cursor Features Effectively

### For This Project

1. **Outline Mode**: Navigate large files in core/src, apps/
2. **Quick Fix**: Clean up warnings, dead code
3. **Codebase Search**: Find usage patterns across modules
4. **Inline Tests**: Understand test patterns by examining existing tests
5. **Terminal**: Run `cargo test` and see results immediately
6. **Composer**: Plan multi-file refactors before executing

### Cursor Composer Workflow for This Project

Example: Refactoring agent lifecycle states

1. Create composer request with files involved
2. Outline the changes needed
3. Generate code changes
4. Review changes in each file
5. Apply changes
6. Run tests to verify
7. Commit with proper message

## Project-Specific Knowledge

### Architecture Patterns

- **Trait-based abstraction**: Model, Agent, Plugin, Repository traits
- **Repository pattern**: AgentRepository, TaskRepository, WorkflowRepository
- **State machines**: AgentLifecycle manages state transitions
- **Producer-consumer**: ExecutionQueue for task distribution
- **Factory pattern**: ModelFactory, PluginFactory

### Key Files by Purpose

| Purpose | Files |
|---------|-------|
| Agent management | `core/src/agent/`, `agent-orchestrator/src/` |
| Workflow execution | `core/src/workflow/` |
| Storage | `core/src/storage/` |
| gRPC service | `core/src/server/`, `core/proto/` |
| Model providers | `models/src/` |
| CLI | `apps/cli/src/` |
| TUI | `apps/tui/src/` |
| Desktop | `apps/desktop/src-tauri/` |

### Common Patterns

**Error Handling**:
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Invalid state")]
    InvalidState,
}

pub type Result<T> = std::result::Result<T, MyError>;
```

**Async Operations**:
```rust
pub async fn do_something() -> Result<T> {
    // Use .await on futures
    let result = async_function().await?;
    Ok(result)
}
```

**Thread Safety**:
```rust
let shared = Arc::new(Mutex::new(data));
let clone = Arc::clone(&shared);
```

## Monitoring and Logging

Use project's structured logging (tracing):

```rust
use tracing::info;

info!(task_id = ?id, status = "completed", "Task finished");
```

Avoid `println!` except in CLI context.

## Documentation

### When to Document

- Public API functions (doc comments)
- Complex algorithms
- Architectural decisions
- Module-level explanations

### Doc Comment Format

```rust
/// Brief description.
///
/// More detailed explanation if needed.
///
/// # Examples
///
/// ```
/// let result = function(input);
/// assert_eq!(result, expected);
/// ```
pub fn function(input: T) -> Result<U> {
    // implementation
}
```

## Current Project Status

- **Version**: 0.54.1
- **Build Status**: âœ… Clean (with minor warnings)
- **Test Status**: âœ… Comprehensive suite passing
- **Main Branch**: `main`
- **Development Branch**: `main`

### Known Minor Issues

- Unused imports in `apps/tui/` (safe to clean up)
- Unused variables in some test/demo code
- Some dead code methods (not currently used but available for future use)

## Getting Help

1. Check code comments for patterns
2. Look at existing tests for examples
3. Review similar implementations in codebase
4. Check git blame for context on older code
5. Ask in progress file if stuck

## Session Workflow

1. **Start**: Update `PROGRESS.md` with "In Progress - Cursor"
2. **Work**: Make focused changes
3. **Test**: Run `cargo test --all` frequently
4. **Lint**: Run `cargo clippy --all` before commit
5. **Commit**: Use proper message format
6. **Update**: Mark task complete in `PROGRESS.md`
7. **Verify**: Ensure build and tests still pass
